# 事件系统指南

本文档涵盖 `Corona::Kernel` 事件总线（EventBus）与事件流（EventStream）的设计要点与使用示例，便于在系统间构建解耦的通信。

## 事件建模约束
- 事件类型需满足 `Event` 概念：可拷贝且可移动（`event/event_concepts.h`）。
- 处理器需满足 `EventHandler` 概念：可调用且参数为 `const T&`。
- 避免在事件内存放裸裸指针或非线程安全资源，尽量使用值类型或 `shared_ptr`。

## 事件总线（IEventBus）
### 发布/订阅流程
```cpp
struct PlayerSpawned { int id; };
auto bus = Corona::Kernel::create_event_bus();

Corona::Kernel::EventId token = bus->subscribe<PlayerSpawned>([](const PlayerSpawned& e) {
    // 处理事件
});

bus->publish(PlayerSpawned{42});
bus->unsubscribe(token);
```
- `subscribe` 根据模板参数自动完成类型索引与处理器封装，返回 `EventId` 供取消订阅。
- `publish` 会复制事件对象并在锁外逐个调用处理器，避免死锁。
- 当处理器抛出异常时，`event_bus.cpp` 会捕获并吞掉异常，保证其他订阅者继续执行；如需记录异常，请在处理器内部自行日志化。

### 线程安全策略
- 内部使用 `std::map<std::type_index, std::vector<Subscription>>` 存储订阅列表。
- 发布时先复制处理器列表，再释放互斥量；这样避免订阅者在回调内再次订阅/取消触发死锁。
- 取消订阅同样受互斥量保护，确保多线程环境下一致性。

## 事件流（EventStream & IEventBusStream）
### 面向具体事件类型的队列
`EventStream<T>` 为每个订阅者维护独立队列，支持不同背压策略与阻塞等待。

```cpp
struct DamageEvent { int target; int value; };
auto stream = Corona::Kernel::EventStream<DamageEvent>{};

Corona::Kernel::EventStreamOptions opts;
opts.max_queue_size = 128;
opts.policy = Corona::Kernel::BackpressurePolicy::DropOldest;

auto sub = stream.subscribe(opts);
stream.publish(DamageEvent{1001, 25});
if (auto evt = sub.wait_for(std::chrono::milliseconds{50})) {
    // 处理事件
}
```

### 背压策略说明
| 策略 | 行为 | 典型场景 |
| ---- | ---- | -------- |
| `Block` | 当队列满时阻塞发布者直到有空位 | 关键事件，不能丢失数据 |
| `DropOldest` | 淘汰最旧事件，再插入新事件 | 状态类事件，只需最新窗口 |
| `DropNewest` | 丢弃当前发布的事件 | 高吞吐但允许丢帧的场景 |

### 订阅生命周期
- `EventSubscription` 通过 RAII 自动在析构时关闭队列并唤醒阻塞线程，避免悬挂指针。
- `wait()`、`wait_for()`、`try_pop()` 在订阅被关闭或队列为空时返回 `std::nullopt`。
- 关闭订阅 (`close`) 后仍可安全析构 `EventStream`；内部引用计数保证资源释放顺序。

### IEventBusStream：集中化管理
`KernelContext` 使用 `create_event_bus_stream()` 为每种事件类型延迟创建 `EventStream<T>`：
```cpp
auto* stream_bus = KernelContext::instance().event_stream();
auto stream = stream_bus->get_stream<DamageEvent>();
```
- `get_stream` 首先尝试无锁读取，若不存在则在锁内执行“检查-注册”双重校验。
- `SystemContext` 将该工厂暴露给所有系统，实现跨系统的异步数据流。

## 测试覆盖
- 详见 `tests/kernel/event_bus_test.cpp` 与 `tests/kernel/event_stream_test.cpp`：
  - 多线程订阅/发布 (`EventStream.ConcurrentPublish` 等)。
  - 背压策略 (`BackpressureDropOldest/DropNewest/Block`)。
  - 异常处理与 RAII (`EventBus.ExceptionSafety`、`EventStream.RAIISubscription`).

借助上述事件设施，可以在保持模块解耦的同时覆盖不同延迟与可靠性需求：同步广播用 EventBus，异步流处理用 EventStream。
