# Corona 游戏引擎设计文档

## 1. 简介

### 1.1 设计哲学
Corona 引擎是一个以 C++20 为基础构建的现代化、高性能、数据驱动的游戏引擎。其核心设计哲学是 **“组合优于继承，数据优于代码”**。我们致力于提供一个高度模块化、可扩展且易于使用的开发平台，让开发者可以专注于创造独特的游戏体验。

### 1.2 设计目标
*   **高内聚，低耦合**: 系统之间通过清晰的接口进行通信，降低依赖，提高可维护性。
*   **插件化**: 引擎的核心功能和扩展功能都以插件形式存在，可按需加载、卸载和替换。
*   **脚本化**: 提供强大的脚本语言支持（如 Lua 或 Python），用于快速原型设计、逻辑编写和热重载。
*   **现代化 C++**: 全面拥抱 C++20 的新特性（Modules, Concepts, Coroutines, Ranges 等），以提升代码质量、编译速度和运行效率。
*   **跨平台**: 设计上考虑多平台支持（Windows, Linux, macOS）。

---

## 2. 核心设计原则

### 2.1 高内聚 / 低耦合
*   **内聚性**: 每个系统（如渲染、物理、音频）只负责单一的职责，其内部实现对其他系统透明。
*   **耦合性**: 系统之间不直接依赖具体实现，而是通过抽象接口或消息总线进行交互。例如，物理系统不会直接调用渲染系统的函数，而是通过事件（如 `PositionUpdatedEvent`）通知其他系统。

### 2.2 插件化架构
引擎本身是一个轻量级的核心（Kernel），所有具体功能（渲染器、物理引擎、音频系统等）都作为独立的插件实现。
*   **插件接口 (`IPlugin`)**: 所有插件都必须实现一个标准接口，用于其生命周期管理（加载、初始化、更新、卸载）。
*   **插件管理器 (`PluginManager`)**: 负责在引擎启动时发现、加载和初始化所有配置的插件，并在引擎关闭时安全地卸载它们。
*   **依赖注入**: 插件之间通过依赖注入来获取对其他系统服务的引用，而不是硬编码依赖。

### 2.3 脚本化
脚本系统是连接底层 C++ 和上层游戏逻辑的桥梁。
*   **双向绑定**: 提供一个自动化的工具或手动绑定的方式，将 C++ 的类、函数和枚举暴露给脚本环境，并允许脚本调用 C++。
*   **逻辑热重载**: 可以在引擎运行时修改并重新加载脚本，无需重新编译整个项目，极大地提高了开发效率。
*   **性能与灵活性的平衡**: 性能敏感的代码（如渲染算法、物理计算）用 C++ 实现，而游戏逻辑、UI 和关卡脚本则使用脚本语言。

---

## 3. 架构概览

引擎采用分层架构，从下至上依次为：

```
+-----------------------------------------+
|              游戏逻辑层 (脚本)            |
+-----------------------------------------+
|              应用层 (编辑器/游戏)         |
+-----------------------------------------+
|                插件层                   |
| +-----------+ +-----------+ +---------+ |
| |  渲染器   | |  物理引擎  | |  音频   | | ...
| +-----------+ +-----------+ +---------+ |
+-----------------------------------------+
|              核心系统 (Kernel)          |
| +-----------+ +-----------+ +---------+ |
| |  日志     | |  文件系统  | |  事件   | | ...
| +-----------+ +-----------+ +---------+ |
+-----------------------------------------+
|              平台抽象层 (PAL)           |
+-----------------------------------------+
```

---

## 4. 核心系统 (Kernel)

Kernel 是引擎的基石，提供最基础的服务，不依赖任何上层模块。
*   **日志系统 (`Logger`)**: 提供分级的日志记录功能。
*   **文件系统 (`FileSystem`)**: 虚拟文件系统，支持对物理文件和打包资源的统一访问。
*   **事件系统 (`EventBus`)**: 一个全局的事件总线，用于模块间的解耦通信。采用发布-订阅模式。
*   **配置系统 (`ConfigManager`)**: 管理引擎和项目的配置。
*   **插件管理器 (`PluginManager`)**: 负责插件的生命周期管理。

---

## 5. 模块化与插件系统

### 5.1 `IPlugin` 接口
```cpp
// 使用 C++20 Modules
export module Corona.IPlugin;

import Corona.Core; // 假设核心类型在此模块

export namespace Corona
{
    class IPlugin
    {
    public:
        virtual ~IPlugin() = default;
        virtual const char* GetName() const = 0;
        virtual void Install() = 0;
        virtual void Uninstall() = 0;
    };
}
```

### 5.2 插件加载流程
1.  引擎启动，`PluginManager` 读取配置文件中的插件列表。
2.  根据列表加载动态链接库（`.dll`, `.so`）。
3.  从库中获取插件实例的创建函数。
4.  创建插件实例，并调用其 `Install()` 方法。
5.  插件在 `Install()` 方法中向核心系统注册自己的服务和事件监听器。

---

## 6. 实体组件系统 (ECS)

我们采用数据驱动的 ECS 架构来管理游戏世界中的对象。
*   **实体 (`Entity`)**: 仅为一个唯一的 ID，没有数据和行为。
*   **组件 (`Component`)**
    *   纯数据结构（Plain Old Data, POD），不包含逻辑。
    *   使用 C++20 的聚合初始化和指定初始化，使其定义更简洁。
    *   示例：`struct TransformComponent { Vector3 position; Quaternion rotation; };`
*   **系统 (`System`)**
    *   包含逻辑，负责处理拥有特定组件组合的实体。
    *   示例：`PhysicsSystem` 会查询所有同时拥有 `TransformComponent` 和 `RigidBodyComponent` 的实体，并对它们进行物理模拟。

---

## 7. 渲染系统

渲染系统被设计为一个可插拔的插件。
*   **渲染抽象层 (RHI)**: 定义一套统一的图形 API 接口（如 `RHICreateBuffer`, `RHIDraw`），屏蔽底层图形 API（DirectX 12, Vulkan, Metal）的差异。
*   **多后端实现**: 针对不同的图形 API，实现不同的 RHI 后端。可以在启动时根据平台和配置选择加载哪个后端。
*   **现代渲染管线**: 支持延迟渲染、基于物理的渲染（PBR）和可编程渲染管线（SRP）。
*   **C++20 Coroutines 应用**: 使用协程来简化异步资源加载（如纹理、模型），避免回调地狱。

```cpp
// 示例：使用协程加载纹理
export import Corona.Renderer;

Task<TextureHandle> LoadTextureAsync(const std::string& path)
{
    // 1. 异步从磁盘读取文件
    auto fileData = co_await FileSystem::ReadAllBytesAsync(path);
    // 2. 在渲染线程上创建 GPU 资源
    auto textureHandle = co_await GpuScheduler::CreateTexture(fileData);
    co_return textureHandle;
}
```

---

## 8. 脚本系统

### 8.1 绑定层
使用模板元编程和 C++20 的 `Concepts` 来简化 C++ 到脚本语言的绑定过程。

```cpp
// 示例：使用 Concept 约束可绑定的函数
export concept CppExportable = std::is_function_v<T> && ...;

template<CppExportable F>
void BindFunction(const std::string& name, F func)
{
    // ... 自动生成绑定代码
}
```

### 8.2 脚本组件
允许将脚本附加到实体上作为一种特殊的组件 (`ScriptComponent`)，其 `OnUpdate` 等生命周期函数会在引擎的更新循环中被调用。

---

## 9. C++20 特性应用

*   **Modules**:
    *   **目的**: 替代传统的头文件（`.h`），解决编译速度慢、宏污染和循环依赖问题。
    *   **应用**: 整个引擎被划分为多个模块，如 `Corona.Core`, `Corona.Renderer`, `Corona.Physics`。接口通过 `export` 关键字暴露。
*   **Concepts**:
    *   **目的**: 在编译期对模板参数进行约束，提供更清晰的错误信息和更强的类型检查。
    *   **应用**: 用于泛型算法、ECS 系统和脚本绑定，确保传入的类型符合预期。
*   **Coroutines (协程)**:
    *   **目的**: 以同步的方式编写异步代码，提高可读性。
    *   **应用**: 用于文件 I/O、网络通信、异步资源加载等耗时操作，避免阻塞主线程。
*   **Ranges**:
    *   **目的**: 提供一种更简洁、可组合的方式来处理数据序列。
    *   **应用**: 在 ECS 系统中，用于过滤和转换组件数据流。
    *   `for (auto& transform : entities | std::views::filter(Has<Velocity>) | std::views::transform(Get<Transform>))`
*   **`std::span`**:
    *   **目的**: 提供对连续内存区域的非拥有视图，安全且高效。
    *   **应用**: 作为函数参数，替代原始指针和大小，或 `std::vector` 的引用，以接受任何连续数据源。

---

## 10. 结论

Corona 引擎旨在通过结合现代 C++20 的强大功能和经过验证的架构模式（插件化、ECS），构建一个灵活、高效且易于扩展的开发平台。这种设计不仅提升了引擎本身的性能和可维护性，也为游戏开发者提供了更流畅、更高效的创作工具链。
